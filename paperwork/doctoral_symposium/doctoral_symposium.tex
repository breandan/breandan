\documentclass[sigplan,screen]{acmart}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers

\usepackage{amsmath}

\begin{document}

\title{Syntax Repair as a Language Game}

\author{Breandan Considine}
%\authornote{Both authors contributed equally to this research.}
\email{bre@ndan.co}
\affiliation{%
  \institution{McGill University}
}

%\author{Lars Th{\o}rv{\"a}ld}
%\affiliation{%
%  \institution{The Th{\o}rv{\"a}ld Group}
%  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
%  \city{Hekla}
%  \country{Iceland}}
%\email{larst@affiliation.org}
%
%\author{Valerie B\'eranger}
%\affiliation{%
%  \institution{Inria Paris-Rocquencourt}
%  \city{Rocquencourt}
%  \country{France}
%}


\renewcommand{\shortauthors}{Considine et al.}

%\begin{abstract}
%  A clear and well-documented \LaTeX\ document is presented as an
%  article formatted for publication by ACM in a conference proceedings
%  or journal publication. Based on the ``acmart'' document class, this
%  article presents and explains many of the common variations, as well
%  as many of the formatting elements an author may use in the
%  preparation of the documentation of their work.
%\end{abstract}

\maketitle

\section{Abstract}

We introduce a novel approach to syntax correction based on the idea of idempotent matrix imputation. Context-free languages are recognized by Boolean matrix multiplication, with potentially some missing entries when incomplete or invalid. We can solve for the missing entries by applying a matrix completion algorithm, and the resulting valid solutions can be ranked by their statistical likelihood, then presented to the user for review.

\section{Motivation}

%Why do we care about the problem and the results? If the problem isn’t obviously interesting it might be better to put motivation first, but if your work is incremental progress on a problem that is widely recognized as important, then it is probably better to put the “Problem” section first to indicate which piece of the larger problem you are breaking off to work on. This section should include the importance of your work, the difficulty of the area, and the impact it might have if successful.

%Through the millennia, human beings have sought ways to mechanize the process of thought. From the abacus to the modern computer, we have constructed increasingly sophisticated systems to augment our cognitive abilities. In the 21st century, we are witnessing the emergence of a new class of intelligent machines, which are capable of learning from experience and solving problems in ways that are difficult to express in code. These machines are known as \emph{artificial neural networks} (ANNs), and they are the subject of intense research in the fields of computer science and statistics.

Are languages acquired or constructed? In empirical software engineering and natural linguistics, many would argue languages are statistical phenomena that arise in the context of repeated social interactions. Tracing linguistic artifacts sheds light into language acquisition and adaption, and offers insight into the social dynamics and cognitive processes of communicating agents. In contrast, programming languages are deliberately constructed and most designers would argue a language's social dynamics, though perhaps informative, are less fundamental than, e.g., its runtime dynamics. This is a curious distinction, since programming languages appear to share many statistical similarities with natural language~\cite{hindle2016naturalness}, and the act of programming can itself be considered a form of communication~\cite{demillo1979social} between a human and a machine.

Our research seeks to understand the common principles that shape the creation and evolution of natural and programming language artifacts, informed by game semantics and formal language theory. In particular, we draw inspiration from both natural and computational linguistics to develop a constructive theory of code completion and program repair. Our proposed framework can be translated into code completion tools for integrated development environments, as well a benchmarking suite to probe the reasoning capabilities of neural language models on program repair tasks.

Language games are an effective framework to model the social dynamics of programming. In one such game, two players, the programmer and a computer, collaborate across a shared workspace to construct a domain-specific language that solves a chosen problem. Initially, both parties have partial visibility of the problem structure and must exchange messages conveying, e.g., their intent, abilities and knowledge to reach a common understanding. This game comes to an end when the chosen problem is successfully solved, the clock eventually runs out, or the problem is deemed unsolvable and one player forfeits.

We call this framework \emph{dialogical alignment} and argue it not only captures many behavioral aspects of social computing such as hackathons and pair programming, but also supports an ergonomic interface for assistive programming, and offers a benchmark for evaluating the systematic reasoning and compositional generalization of intelligent programming tools (IPT). In light of the growing reliance upon IPTs to help solve hard technical challenges, we propose tools and benchmarks to increase the assurance and reliability of programming agents on a curriculum of language games.

Transformers can demonstrate compositional generalization on certain language generation tasks but the current state-of-the-art procedure for reasoning is essentially, ``Let's think step-by-step\ldots'' prompting of a feedforward transformer-based language model with human preference alignment. A few issues with this model arise: (1) human preferences can be misleading, (2) Transformers are known to take shortcuts to reasoning~\cite{dziri2023faith, liu2022transformers}, and (3) there is mounting evidence to suggest that transformers have foundational limits to expressivity~\cite{merrill2022saturated, chiang2023tighter}.

The proper way to evaluate systematic reasoning is not by grounding language models on natural language preferences, but by training on a curriculum of language games with increasing average-case complexity like proof search or program repair. This provides a more reliable indicator of systematic reasoning and a more trustworthy alignment criteria - namely correctness rather than preferability.

As a concrete instance of one such problem in formal languages, we study syntactic program repair. We have developed a strong classical baseline, namely discrete search augmented with a weak ranking metric. We evaluate it on a variety of toy and practical programming languages, showing SoTA precision and throughput at a fixed timeout relative to transformers. As a strong baseline, Tidyparse is a useful tool in its own right for program repair.

\section{Problem}

%What exact problem, issue, or question does this research address? What limitations or failings of current understanding, knowledge, methods, or technologies does this research resolve? You should position your work with respect to related ideas in this section.



Programming is an exercise in gradual refinement. Broadly speaking, program repair is the task of refining a program that loosely approximates a specification, but contains some mistakes. Programming in this regard is a bit like a limit-process: the more we refine our specification, the closer we get to a program that solves the problem. In practice, programmers often fall short. In some cases, we can use an automated procedure to identify and repair the remaining mistakes.

The syntax of programming languages is typically defined in terms of a formal grammar. Invalid programs are often the result of a typographic mistake. In this case, the programmer must correct the mistake, which can be a tedious and error-prone process. Automatic correction is often ambiguous, and the set of probable programs are often a small fragment of those which are grammatically valid.

We seek to develop a method for automatically correcting syntax errors in programming languages. This is a special case of error-correcting codes in communication theory, whose input takes the form of an invalid or corrupt program and the output is a valid program.

\section{Approach}

%How did you go about solving or making progress on the problem? What new understanding, knowledge, methods, or technologies will this research generate?

We propose a novel approach to syntax correction based on the idea of idempotent matrix imputation. Context-free languages are recognized by Boolean matrix multiplication, with potentially some missing entries when incomplete or invalid. We can solve for the missing entries by applying a matrix completion algorithm, and the resulting valid solutions can be ranked by their statistical likelihood, then presented to the user for review.

\section{Evaluation Methodology}

%In writing the evaluation methodology section of your submission, we encourage you to emphasize two main aspects of your experiment:

We evaluate our method on a dataset of human mistakes and corrections.

\subsection{Hypothesis}

%What would be the main research result? What would be the secondary research results? Phrase these as primary and secondary hypotheses.

\subsection{Evaluation Setup}

%How are you going to set up your experiments or studies to test these hypotheses? How do you plan to control for bias? How will you maximize external validity?

%bibliography:
\bibliography{doctoral_symposium}
\bibliographystyle{ACM-Reference-Format}
\end{document}
\endinput