# Research Statement

I am a software engineer at McGill University under the supervision of Jin Guo. During my Ph.D. studies, I want to build a tool to help software engineers find information more easily and reason about their software more clearly, using learning.

## Introduction

Graphs are general purpose data structures which are used to represent many interesting concepts. All of the following things are graphs:

- Sets: data, multisets, posets, symbols
- Sequences: Lists, strings, traces, linear function composition
- Trees: Abstract syntax trees, [document object model](https://en.wikipedia.org/wiki/Document_Object_Model), phylogeny
- DAGs: [Git](https://eagain.net/articles/git-for-computer-scientists/), [control flow](https://en.wikipedia.org/wiki/Control-flow_graph), citation networks
- Directed graphs: [State machines](https://en.wikipedia.org/wiki/Finite-state_machine), [knowledge graphs](https://en.wikipedia.org/wiki/Knowledge_Graph), [lambda calculus](http://dkeenan.com/Lambda/), web pages, neural networks
- Hypergraphs: [Zettelkasten](https://zettelkasten.de/), [categories](https://en.wikipedia.org/wiki/Category_theory), [the universe](https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/)

Today's computers are becoming smarter and more creative. They can perform many useful tasks for humans writing software.

According to software engineers, the best way to understand something is to build it.

## Roadmap

I believe that if we are going to learn to program, we must start by learning very simple programs. To learn what a program does, I believe that we must first learn what a program means. According to Noam Chomsky, the simplest type of program is a finite state machine.

- Synthesize a finite state machine
- Use Angulin's L* algorithm as an oracle
- Use the finite state machine to search for relevant programs (i.e. recommend code)
- Synthesize a Buchi automaton
- Synthesize a Pushdown automaton
- Synthesize a Linear bounded automaton
- ?

## Where are we now?

## Practial Applications

## Milestones
